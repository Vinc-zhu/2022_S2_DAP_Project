---
title: "DAP_Project"
author: "Jinfeng Zhu"
date: "2022-08-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#Installing libraries
library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)

library(janitor) # to clean column names 
library(psych)   # for the describe function

library("stringr") # to add leading zeros

```

# 1. Exploratory Data Analysis
## 1.1 Import Data
```{r import data, include=FALSE}
data_death      <- read_csv("Data/death.csv")
data_health_ins <- read_csv("Data/healthinsurance.csv")
data_incidence  <- read_csv("Data/incidence.csv")
data_income     <- read_csv("Data/income.csv")
data_population <- read_csv("Data/population.csv")
data_poverty    <- read_csv("Data/poverty.csv")
```

## EDA Framework
## 1.2 Data Exploration 
```{r view data}
head(data_death)
head(data_health_ins)
head(data_incidence)
head(data_income)
head(data_population)
head(data_poverty)
```

### 1.2.1 Reshaping Data into Tidy Form
Data will be in tidy form if it has the following 3 properties:
1. Each variable forms a column
2. Each observation forms a row
3. Each type of observational unit (e.g. persons, schools, counties) forms a table
Sometimes data in tidy form may also be known as data in long form.



## 1.3 Assess Data Quality

### 1.3.1 Summarise Data
```{r clean header names}
data_death_clean      <- clean_names(data_death)
data_health_ins_clean <- clean_names(data_health_ins)
data_incidence_clean  <- clean_names(data_incidence)
data_income_clean     <- clean_names(data_income)
data_population_clean <- clean_names(data_population)
data_poverty_clean    <- clean_names(data_poverty)

names(data_death_clean)
names(data_health_ins_clean)
names(data_incidence_clean)
names(data_income_clean)       
names(data_population_clean)  
names(data_poverty_clean)

```


### 1.3.2 Visualise and Analyse Patterns in Data


## 1.4 Manipulate and Cleanse the Data
### 1.4.1 Clean FIPS
```{r FIPS}
# Make FIPS a 5-digit code 
# For death and incidence data, most of the FIPS codes are 5-digits but if they are 4-digits, you will need to add a 0 in front. 
data_death_clean_fips <- data_death_clean %>% 
  mutate(fips_clean = str_pad(data_death_clean$fips, width = 5, pad = "0"))

data_incidence_clean_fips <- data_incidence_clean %>% 
  mutate(fips_clean = str_pad(data_incidence_clean$fips, width = 5, pad = "0"))

# For poverty, health insurance, income and population data, you will need to combine State FIPS and County FIPS to get the 5-digit code.
data_health_ins_clean_fips <- data_health_ins_clean %>% 
  mutate(state_fips_clean  = str_pad(data_health_ins_clean$state_fips, width = 2, pad = "0")) %>% 
  mutate(county_fips_clean = str_pad(data_health_ins_clean$county_fips, width = 3, pad = "0")) %>% 
  mutate(fips_clean = paste(state_fips_clean, county_fips_clean, sep=""))

data_income_clean_fips <- data_income_clean %>% 
  mutate(state_fips_clean  = str_pad(data_income_clean$state_fips, width = 2, pad = "0")) %>% 
  mutate(county_fips_clean = str_pad(data_income_clean$county_fips, width = 3, pad = "0")) %>% 
  mutate(fips_clean = paste(state_fips_clean, county_fips_clean, sep=""))

data_population_clean_fips <- data_population_clean %>% 
  mutate(state_fips_clean  = str_pad(data_population_clean$state, width = 2, pad = "0")) %>% 
  mutate(county_fips_clean = str_pad(data_population_clean$county, width = 3, pad = "0")) %>% 
  mutate(fips_clean = paste(state_fips_clean, county_fips_clean, sep=""))

data_poverty_clean_fips <- data_poverty_clean %>% 
  mutate(state_fips_clean  = str_pad(data_poverty_clean$state_fips, width = 2, pad = "0")) %>% 
  mutate(county_fips_clean = str_pad(data_poverty_clean$county_fips, width = 3, pad = "0")) %>% 
  mutate(fips_clean = paste(state_fips_clean, county_fips_clean, sep=""))


# Check in EXCEL: 
# write_excel_csv(data_population_clean_fips, "population_clean_fips.csv", col_names = TRUE)

```


## 1.5 Refine questions/generate new questions (optional)


EDA should not be viewed as just conducting the above framework as a series of ordered steps. This is far too simplistic as EDA typically involves multiple rounds of each step. For example, visualisations could give you new ideas for summaries you would be interested in and perhaps patterns you want to analyse, which could lead to more manipulations to the data and visualisations.


### Internal Checks
### Check FIPS
Check if there are duplicate FIPS
```{r check FIPS}
dim(data_death_clean_fips)[1] == length(unique(data_death_clean_fips$fips_clean)) # No duplicates
dim(data_incidence_clean_fips)[1] == length(unique(data_incidence_clean_fips$fips_clean)) # No duplicates
dim(data_health_ins_clean_fips)[1] == length(unique(data_health_ins_clean_fips$fips_clean)) # No duplicates
dim(data_income_clean_fips)[1] == length(unique(data_income_clean_fips$fips_clean)) # No duplicates
dim(data_population_clean_fips)[1] == length(unique(data_population_clean_fips$fips_clean)) # No duplicates
dim(data_poverty_clean_fips)[1] == length(unique(data_poverty_clean_fips$fips_clean)) # No duplicates 
```


# Correlation




```{r}
describe(data_poverty)
```


Exploratory data analysis

Objectives:
•Suggest hypotheses
•Assess assumptions made
•Support selection of appropriate models
•Provide basis for further data collection


FrameworK:
1. Assess the data quality

